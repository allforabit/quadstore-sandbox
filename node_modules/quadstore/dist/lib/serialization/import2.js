"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readQuad = exports.writePattern = exports.writeQuad = exports.copyBufferIntoBuffer = void 0;
const types_1 = require("../types");
const xsd = __importStar(require("./xsd"));
const fpstring_1 = require("./fpstring");
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const copyBufferIntoBuffer = (source, target, targetFrom) => {
    source.copy(target, targetFrom, 0, source.byteLength);
};
exports.copyBufferIntoBuffer = copyBufferIntoBuffer;
const namedNodeWriter = {
    writtenKeyBytes: 0,
    writtenValueBytes: 0,
    writeToQuad(key, keyOffset, value, valueOffset, node) {
        const encodedValue = Buffer.from(node.value);
        exports.copyBufferIntoBuffer(encodedValue, key, keyOffset);
        this.writtenKeyBytes = encodedValue.byteLength;
        if (value) {
            value.writeUInt16LE(encodedValue.byteLength, valueOffset);
            this.writtenValueBytes = 2;
        }
    },
    writeToPattern(key, keyOffset, node) {
        this.writeToQuad(key, keyOffset, undefined, undefined, node);
    },
};
const namedNodeReader = {
    readKeyBytes: 0,
    readValueBytes: 0,
    readFromQuad(key, keyOffset, value, valueOffset, factory) {
        const valueLen = value.readUInt16LE(valueOffset);
        this.readValueBytes = 2;
        this.readKeyBytes = valueLen;
        console.log(`reading named node keyOffset ${keyOffset} keyTo ${keyOffset + valueLen} len ${valueLen}`);
        return factory.namedNode(key.slice(keyOffset, keyOffset + valueLen).toString());
    },
};
const blankNodeWriter = {
    writtenKeyBytes: 0,
    writtenValueBytes: 0,
    writeToQuad(key, keyOffset, value, valueOffset, node) {
        const encodedValue = Buffer.from(node.value);
        exports.copyBufferIntoBuffer(encodedValue, key, keyOffset);
        this.writtenKeyBytes = encodedValue.byteLength;
        if (value) {
            this.writtenValueBytes = 2;
            value.writeUInt16LE(encodedValue.byteLength, valueOffset);
        }
    },
    writeToPattern(key, keyOffset, node) {
        this.writeToQuad(key, keyOffset, undefined, undefined, node);
    },
};
const blankNodeReader = {
    readKeyBytes: 0,
    readValueBytes: 0,
    readFromQuad(key, keyOffset, value, valueOffset, factory) {
        const valueLen = value.readUInt16LE(valueOffset);
        this.readValueBytes = 2;
        this.readKeyBytes = valueLen;
        return factory.blankNode(key.slice(keyOffset, keyOffset + valueLen).toString());
    },
};
const genericLiteralWriter = {
    writtenKeyBytes: 0,
    writtenValueBytes: 0,
    _currentKeyOffset: 0,
    writeToQuad(key, keyOffset, value, valueOffset, node, separator) {
        const encodedValue = Buffer.from(node.value);
        const encodedDatatypeValue = Buffer.from(node.datatype.value);
        this._currentKeyOffset = keyOffset;
        exports.copyBufferIntoBuffer(encodedDatatypeValue, key, this._currentKeyOffset);
        this._currentKeyOffset += encodedDatatypeValue.byteLength;
        exports.copyBufferIntoBuffer(separator, key, this._currentKeyOffset);
        this._currentKeyOffset += separator.byteLength;
        exports.copyBufferIntoBuffer(encodedValue, key, this._currentKeyOffset);
        this._currentKeyOffset += encodedValue.byteLength;
        this.writtenKeyBytes = this._currentKeyOffset - keyOffset;
        if (value) {
            value.writeUInt16LE(encodedValue.byteLength, valueOffset);
            value.writeUInt16LE(encodedDatatypeValue.byteLength, valueOffset + 2);
            this.writtenValueBytes = 4;
        }
    },
    writeToPattern(key, keyOffset, node, separator) {
        this.writeToQuad(key, keyOffset, undefined, undefined, node, separator);
    },
};
const genericLiteralReader = {
    readKeyBytes: 0,
    readValueBytes: 0,
    readFromQuad(key, keyOffset, value, valueOffset, factory, separator) {
        const valueLen = value.readUInt16LE(valueOffset);
        const datatypeValueLen = value.readUInt16LE(valueOffset + 2);
        this.readValueBytes = 4;
        this.readKeyBytes = valueLen + separator.byteLength + datatypeValueLen;
        return factory.literal(key.slice(keyOffset + datatypeValueLen + separator.byteLength, valueLen).toString(), factory.namedNode(key.slice(keyOffset, datatypeValueLen).toString()));
    },
};
const stringLiteralWriter = {
    writtenKeyBytes: 0,
    writtenValueBytes: 0,
    writeToQuad(key, keyOffset, value, valueOffset, node) {
        const encodedValue = Buffer.from(node.value);
        exports.copyBufferIntoBuffer(encodedValue, key, keyOffset);
        this.writtenKeyBytes = encodedValue.byteLength;
        if (value) {
            value.writeUInt16LE(encodedValue.byteLength, valueOffset);
            this.writtenValueBytes = 2;
        }
    },
    writeToPattern(key, keyOffset, node) {
        this.writeToQuad(key, keyOffset, undefined, undefined, node);
    },
};
const stringLiteralReader = {
    readKeyBytes: 0,
    readValueBytes: 0,
    readFromQuad(key, keyOffset, value, valueOffset, factory) {
        const valueLen = value.readUInt16LE(valueOffset);
        this.readValueBytes = 2;
        this.readKeyBytes = valueLen;
        return factory.literal(key.subarray(keyOffset, valueLen).toString());
    },
};
const langStringLiteralWriter = {
    writtenKeyBytes: 0,
    writtenValueBytes: 0,
    _currentKeyOffset: 0,
    writeToQuad(key, keyOffset, value, valueOffset, node, separator) {
        const encodedValue = Buffer.from(node.value);
        const encodedLangCode = Buffer.from(node.language);
        this._currentKeyOffset = keyOffset;
        exports.copyBufferIntoBuffer(encodedLangCode, key, this._currentKeyOffset);
        this._currentKeyOffset += encodedLangCode.byteLength;
        exports.copyBufferIntoBuffer(separator, key, this._currentKeyOffset);
        this._currentKeyOffset += separator.byteLength;
        exports.copyBufferIntoBuffer(encodedValue, key, this._currentKeyOffset);
        this._currentKeyOffset += encodedValue.byteLength;
        this.writtenKeyBytes = this._currentKeyOffset - keyOffset;
        if (value) {
            value.writeUInt16LE(encodedValue.byteLength, valueOffset);
            value.writeUInt16LE(encodedLangCode.byteLength, valueOffset + 2);
            this.writtenValueBytes = 4;
        }
    },
    writeToPattern(key, keyOffset, node, separator) {
        this.writeToQuad(key, keyOffset, undefined, undefined, node, separator);
    },
};
const langStringLiteralReader = {
    readKeyBytes: 0,
    readValueBytes: 0,
    readFromQuad(key, keyOffset, value, valueOffset, factory, separator) {
        const valueLen = value.readUInt16LE(valueOffset);
        const langCodeLen = value.readUInt16LE(valueOffset + 2);
        this.readValueBytes = 4;
        this.readKeyBytes = valueLen + separator.byteLength + langCodeLen;
        return factory.literal(key.subarray(keyOffset + langCodeLen + separator.byteLength, valueLen).toString(), key.subarray(keyOffset, langCodeLen).toString());
    },
};
const numericLiteralWriter = {
    writtenKeyBytes: 0,
    writtenValueBytes: 0,
    _currentKeyOffset: 0,
    writeToQuad(key, keyOffset, value, valueOffset, node, separator, encodedNumericValue, rangeMode) {
        const encodedValue = Buffer.from(node.value);
        const encodedDatatypeValue = Buffer.from(node.datatype.value);
        this._currentKeyOffset = keyOffset;
        exports.copyBufferIntoBuffer(encodedNumericValue, key, this._currentKeyOffset);
        this._currentKeyOffset += encodedNumericValue.byteLength;
        if (!rangeMode) {
            exports.copyBufferIntoBuffer(separator, key, this._currentKeyOffset);
            this._currentKeyOffset += separator.byteLength;
            exports.copyBufferIntoBuffer(encodedDatatypeValue, key, this._currentKeyOffset);
            this._currentKeyOffset += encodedDatatypeValue.byteLength;
            exports.copyBufferIntoBuffer(separator, key, this._currentKeyOffset);
            this._currentKeyOffset += separator.byteLength;
            exports.copyBufferIntoBuffer(encodedValue, key, this._currentKeyOffset);
            this._currentKeyOffset += encodedValue.byteLength;
        }
        this.writtenKeyBytes = this._currentKeyOffset - keyOffset;
        if (value) {
            value.writeUInt16LE(encodedValue.byteLength, valueOffset);
            value.writeUInt16LE(encodedDatatypeValue.byteLength, valueOffset + 2);
            value.writeUInt16LE(encodedNumericValue.byteLength, valueOffset + 4);
            this.writtenValueBytes = 6;
        }
    },
    writeToPattern(key, keyOffset, node, separator, encodedNumericValue, rangeMode) {
        this.writeToQuad(key, keyOffset, undefined, undefined, node, separator, encodedNumericValue, rangeMode);
    },
};
const numericLiteralReader = {
    readKeyBytes: 0,
    readValueBytes: 0,
    readFromQuad(key, keyOffset, value, valueOffset, factory, separator) {
        const valueLen = value.readUInt16LE(valueOffset);
        const datatypeValueLen = value.readUInt16LE(valueOffset + 2);
        const numericValueLen = value.readUInt16LE(valueOffset + 4);
        this.readValueBytes = 6;
        this.readKeyBytes = valueLen + separator.byteLength + datatypeValueLen + separator.byteLength + numericValueLen;
        return factory.literal(key.subarray(keyOffset + numericValueLen + separator.byteLength + datatypeValueLen + separator.byteLength, valueLen).toString(), factory.namedNode(key.subarray(keyOffset + numericValueLen + separator.byteLength, datatypeValueLen).toString()));
    },
};
const defaultGraphWriter = {
    writtenKeyBytes: 0,
    writtenValueBytes: 0,
    writeToQuad(key, keyOffset, value, valueOffset, node) {
        const encodedValue = Buffer.from('dg');
        exports.copyBufferIntoBuffer(encodedValue, key, keyOffset);
        this.writtenKeyBytes = encodedValue.byteLength;
        if (value) {
            value.writeUInt16LE(encodedValue.byteLength, valueOffset);
            this.writtenValueBytes = 2;
        }
    },
    writeToPattern(key, keyOffset, node) {
        this.writeToQuad(key, keyOffset, undefined, undefined, node);
    },
};
const defaultGraphReader = {
    readKeyBytes: 0,
    readValueBytes: 0,
    readFromQuad(key, keyOffset, value, valueOffset, factory) {
        const valueLen = value.readUInt16LE(valueOffset);
        this.readValueBytes = 2;
        this.readKeyBytes = valueLen;
        return factory.defaultGraph();
    },
};
const writeQuad = (key, keyOffset, value, valueOffset, separator, quad, termNames) => {
    for (let t = 0, term; t < termNames.length; t += 1) {
        term = quad[termNames[t]];
        switch (term.termType) {
            case 'NamedNode':
                value.writeUInt16LE(0, valueOffset);
                valueOffset += 2;
                namedNodeWriter.writeToQuad(key, keyOffset, value, valueOffset, term);
                keyOffset += namedNodeWriter.writtenKeyBytes;
                valueOffset += namedNodeWriter.writtenValueBytes;
                break;
            case 'BlankNode':
                value.writeUInt16LE(1, valueOffset);
                valueOffset += 2;
                blankNodeWriter.writeToQuad(key, keyOffset, value, valueOffset, term);
                keyOffset += blankNodeWriter.writtenKeyBytes;
                valueOffset += blankNodeWriter.writtenValueBytes;
                break;
            case 'DefaultGraph':
                value.writeUInt16LE(6, valueOffset);
                valueOffset += 2;
                defaultGraphWriter.writeToQuad(key, keyOffset, value, valueOffset, term);
                keyOffset += defaultGraphWriter.writtenKeyBytes;
                valueOffset += defaultGraphWriter.writtenValueBytes;
                break;
            case 'Literal':
                if (term.language) {
                    value.writeUInt16LE(4, valueOffset);
                    valueOffset += 2;
                    langStringLiteralWriter.writeToQuad(key, keyOffset, value, valueOffset, term, separator);
                    keyOffset += langStringLiteralWriter.writtenKeyBytes;
                    valueOffset += langStringLiteralWriter.writtenValueBytes;
                }
                else if (term.datatype) {
                    switch (term.datatype.value) {
                        case xsd.string:
                            value.writeUInt16LE(3, valueOffset);
                            valueOffset += 2;
                            stringLiteralWriter.writeToQuad(key, keyOffset, value, valueOffset, term);
                            keyOffset += stringLiteralWriter.writtenKeyBytes;
                            valueOffset += stringLiteralWriter.writtenValueBytes;
                            break;
                        case xsd.integer:
                        case xsd.double:
                        case xsd.decimal:
                        case xsd.nonPositiveInteger:
                        case xsd.negativeInteger:
                        case xsd.long:
                        case xsd.int:
                        case xsd.short:
                        case xsd.byte:
                        case xsd.nonNegativeInteger:
                        case xsd.unsignedLong:
                        case xsd.unsignedInt:
                        case xsd.unsignedShort:
                        case xsd.unsignedByte:
                        case xsd.positiveInteger:
                            value.writeUInt16LE(5, valueOffset);
                            valueOffset += 2;
                            numericLiteralWriter.writeToQuad(key, keyOffset, value, valueOffset, term, separator, Buffer.from(fpstring_1.encode(term.value)), false);
                            keyOffset += numericLiteralWriter.writtenKeyBytes;
                            valueOffset += numericLiteralWriter.writtenValueBytes;
                            break;
                        case xsd.dateTime:
                            value.writeUInt16LE(5, valueOffset);
                            valueOffset += 2;
                            numericLiteralWriter.writeToQuad(key, keyOffset, value, valueOffset, term, separator, Buffer.from(new Date(term.value).valueOf().toString()), false);
                            keyOffset += numericLiteralWriter.writtenKeyBytes;
                            valueOffset += numericLiteralWriter.writtenValueBytes;
                            break;
                        default:
                            value.writeUInt16LE(2, valueOffset);
                            valueOffset += 2;
                            genericLiteralWriter.writeToQuad(key, keyOffset, value, valueOffset, term, separator);
                            keyOffset += genericLiteralWriter.writtenKeyBytes;
                            valueOffset += genericLiteralWriter.writtenValueBytes;
                    }
                }
                else {
                    value.writeUInt16LE(3, valueOffset);
                    valueOffset += 2;
                    stringLiteralWriter.writeToQuad(key, keyOffset, value, valueOffset, term);
                    keyOffset += stringLiteralWriter.writtenKeyBytes;
                    valueOffset += stringLiteralWriter.writtenValueBytes;
                }
        }
        exports.copyBufferIntoBuffer(separator, key, keyOffset);
        keyOffset += separator.byteLength;
    }
    return { key: Buffer.from(key.subarray(0, keyOffset)), value: Buffer.from(value.subarray(0, valueOffset)) };
};
exports.writeQuad = writeQuad;
const patternLiteralWriter = {
    writtenKeyBytes: 0,
    writeToPattern(key, keyOffset, separator, term) {
        if (term.language) {
            langStringLiteralWriter.writeToPattern(key, keyOffset, term, separator);
            this.writtenKeyBytes = langStringLiteralWriter.writtenKeyBytes;
        }
        else if (term.datatype) {
            switch (term.datatype.value) {
                case xsd.string:
                    stringLiteralWriter.writeToPattern(key, keyOffset, term);
                    this.writtenKeyBytes = stringLiteralWriter.writtenKeyBytes;
                    break;
                case xsd.integer:
                case xsd.double:
                case xsd.decimal:
                case xsd.nonPositiveInteger:
                case xsd.negativeInteger:
                case xsd.long:
                case xsd.int:
                case xsd.short:
                case xsd.byte:
                case xsd.nonNegativeInteger:
                case xsd.unsignedLong:
                case xsd.unsignedInt:
                case xsd.unsignedShort:
                case xsd.unsignedByte:
                case xsd.positiveInteger:
                    numericLiteralWriter.writeToPattern(key, keyOffset, term, separator, Buffer.from(fpstring_1.encode(term.value)), true);
                    this.writtenKeyBytes = numericLiteralWriter.writtenKeyBytes;
                    break;
                case xsd.dateTime:
                    numericLiteralWriter.writeToPattern(key, keyOffset, term, separator, Buffer.from(new Date(term.value).valueOf().toString()), true);
                    this.writtenKeyBytes = numericLiteralWriter.writtenKeyBytes;
                    break;
                default:
                    genericLiteralWriter.writeToPattern(key, keyOffset, term, separator);
                    this.writtenKeyBytes = genericLiteralWriter.writtenKeyBytes;
            }
        }
        else {
            stringLiteralWriter.writeToPattern(key, keyOffset, term);
            this.writtenKeyBytes = stringLiteralWriter.writtenKeyBytes;
        }
    }
};
const writePattern = (pattern, gt, gtFrom, lt, ltFrom, separator, boundary, termNames) => {
    let gte = true;
    let lte = true;
    let didRangeOrLiteral = false;
    let remaining = Object.keys(pattern).length;
    if (remaining === 0) {
        exports.copyBufferIntoBuffer(boundary, lt, ltFrom);
        ltFrom += boundary.byteLength;
        return { gt, lt, gte, lte };
    }
    for (let t = 0; t < termNames.length && remaining > 0; t += 1) {
        const term = pattern[termNames[t]];
        if (!term) {
            return false;
        }
        if (didRangeOrLiteral) {
            return false;
        }
        switch (term.termType) {
            case 'Range':
                didRangeOrLiteral = true;
                if (term.gt) {
                    patternLiteralWriter.writeToPattern(gt, gtFrom, separator, term.gt);
                    gtFrom += patternLiteralWriter.writtenKeyBytes;
                    gte = false;
                }
                else if (term.gte) {
                    patternLiteralWriter.writeToPattern(gt, gtFrom, separator, term.gte);
                    gtFrom += patternLiteralWriter.writtenKeyBytes;
                    gte = true;
                }
                if (term.lt) {
                    patternLiteralWriter.writeToPattern(lt, ltFrom, separator, term.lt);
                    ltFrom += patternLiteralWriter.writtenKeyBytes;
                    lte = false;
                }
                else if (term.lte) {
                    patternLiteralWriter.writeToPattern(lt, ltFrom, separator, term.lte);
                    ltFrom += patternLiteralWriter.writtenKeyBytes;
                    lte = true;
                }
                break;
            case 'Literal':
                didRangeOrLiteral = true;
                patternLiteralWriter.writeToPattern(gt, gtFrom, separator, term);
                gtFrom += patternLiteralWriter.writtenKeyBytes;
                gte = true;
                patternLiteralWriter.writeToPattern(lt, ltFrom, separator, term);
                ltFrom += patternLiteralWriter.writtenKeyBytes;
                lte = true;
                break;
            case 'NamedNode':
                namedNodeWriter.writeToPattern(gt, gtFrom, term);
                gtFrom += namedNodeWriter.writtenKeyBytes;
                gte = true;
                namedNodeWriter.writeToPattern(lt, ltFrom, term);
                ltFrom += namedNodeWriter.writtenKeyBytes;
                lte = true;
                break;
            case 'BlankNode':
                blankNodeWriter.writeToPattern(gt, gtFrom, term);
                gtFrom += blankNodeWriter.writtenKeyBytes;
                gte = true;
                blankNodeWriter.writeToPattern(lt, ltFrom, term);
                ltFrom += blankNodeWriter.writtenKeyBytes;
                lte = true;
                break;
            case 'DefaultGraph':
                defaultGraphWriter.writeToPattern(gt, gtFrom, term);
                gtFrom += defaultGraphWriter.writtenKeyBytes;
                gte = true;
                defaultGraphWriter.writeToPattern(lt, ltFrom, term);
                ltFrom += defaultGraphWriter.writtenKeyBytes;
                lte = true;
                break;
        }
        remaining -= 1;
        if (remaining > 0 && t < termNames.length - 1) {
            exports.copyBufferIntoBuffer(separator, gt, gtFrom);
            gtFrom += separator.byteLength;
            exports.copyBufferIntoBuffer(separator, lt, ltFrom);
            ltFrom += separator.byteLength;
        }
    }
    if (lte) {
        if (didRangeOrLiteral) {
            exports.copyBufferIntoBuffer(boundary, lt, ltFrom);
            ltFrom += boundary.byteLength;
        }
        else {
            exports.copyBufferIntoBuffer(separator, lt, ltFrom);
            ltFrom += separator.byteLength;
            exports.copyBufferIntoBuffer(boundary, lt, ltFrom);
            ltFrom += boundary.byteLength;
        }
    }
    else {
        exports.copyBufferIntoBuffer(separator, lt, ltFrom);
        ltFrom += separator.byteLength;
    }
    if (gte) {
        if (!didRangeOrLiteral) {
            exports.copyBufferIntoBuffer(separator, gt, gtFrom);
            gtFrom += separator.byteLength;
        }
    }
    else {
        if (didRangeOrLiteral) {
            exports.copyBufferIntoBuffer(boundary, gt, gtFrom);
            gtFrom += boundary.byteLength;
        }
        else {
            exports.copyBufferIntoBuffer(separator, gt, gtFrom);
            gtFrom += separator.byteLength;
            exports.copyBufferIntoBuffer(boundary, gt, gtFrom);
            gtFrom += boundary.byteLength;
        }
    }
    return { gt: Buffer.from(gt.slice(0, gtFrom)), lt: Buffer.from(lt.slice(0, ltFrom)), gte, lte };
};
exports.writePattern = writePattern;
const readQuad = (key, keyOffset, value, valueOffset, separator, termNames, factory) => {
    const terms = {};
    for (let t = 0, termName, reader; t < termNames.length; t += 1) {
        termName = termNames[t];
        console.log(`reading term ${t} ${termName} keyOffset ${keyOffset} valueOffset ${valueOffset} of type ${value[valueOffset]}`);
        const encodedTermType = value.readUInt16LE(valueOffset);
        valueOffset += 2;
        switch (encodedTermType) {
            case 0:
                terms[termName] = namedNodeReader.readFromQuad(key, keyOffset, value, valueOffset, factory);
                keyOffset += namedNodeReader.readKeyBytes;
                valueOffset += namedNodeReader.readValueBytes;
                break;
            case 1:
                terms[termName] = blankNodeReader.readFromQuad(key, keyOffset, value, valueOffset, factory);
                keyOffset += blankNodeReader.readKeyBytes;
                valueOffset += blankNodeReader.readValueBytes;
                break;
            case 2:
                terms[termName] = genericLiteralReader.readFromQuad(key, keyOffset, value, valueOffset, factory, separator);
                keyOffset += genericLiteralReader.readKeyBytes;
                valueOffset += genericLiteralReader.readValueBytes;
                break;
            case 3:
                terms[termName] = stringLiteralReader.readFromQuad(key, keyOffset, value, valueOffset, factory);
                keyOffset += stringLiteralReader.readKeyBytes;
                valueOffset += stringLiteralReader.readValueBytes;
                break;
            case 4:
                terms[termName] = langStringLiteralReader.readFromQuad(key, keyOffset, value, valueOffset, factory, separator);
                keyOffset += langStringLiteralReader.readKeyBytes;
                valueOffset += langStringLiteralReader.readValueBytes;
                break;
            case 5:
                terms[termName] = numericLiteralReader.readFromQuad(key, keyOffset, value, valueOffset, factory, separator);
                keyOffset += numericLiteralReader.readKeyBytes;
                valueOffset += numericLiteralReader.readValueBytes;
                break;
            case 6:
                terms[termName] = defaultGraphReader.readFromQuad(key, keyOffset, value, valueOffset, factory);
                keyOffset += defaultGraphReader.readKeyBytes;
                valueOffset += defaultGraphReader.readValueBytes;
                break;
            default: throw new Error(`Unexpected encoded term type "${encodedTermType}"`);
        }
        keyOffset += separator.byteLength;
    }
    return factory.quad(terms.subject, terms.predicate, terms.object, terms.graph);
};
exports.readQuad = readQuad;
if (require.main === module) {
    const { DataFactory } = require('rdf-data-factory');
    const factory = new DataFactory();
    const quad = factory.quad(factory.namedNode('http://ex.com/s'), factory.namedNode('http://ex.com/pppp'), factory.namedNode('http://ex.com/o'), factory.namedNode('http://ex.com/gg'));
    const termNames = [types_1.TermName.PREDICATE, types_1.TermName.OBJECT, types_1.TermName.GRAPH, types_1.TermName.SUBJECT];
    const key = Buffer.alloc(8192 * 6);
    const value = Buffer.alloc(8192 * 6);
    const separator = Buffer.from('\u0000\u0000');
    const boundary = Buffer.from('\uDBFF\uDFFF');
    exports.copyBufferIntoBuffer(Buffer.from('SPOG'), key, 0);
    exports.writeQuad(key, 4, value, 0, separator, quad, termNames);
    console.log(textDecoder.decode(key));
    const read = exports.readQuad(key, 4, value, 0, separator, termNames, factory);
    console.log('QUAD', quad);
    console.log('READ', read);
    const gt = Buffer.alloc(8192 * 6);
    const lt = Buffer.alloc(8192 * 6);
    textEncoder.encodeInto('SPOG', gt);
    textEncoder.encodeInto('SPOG', lt);
    exports.writePattern({
        predicate: factory.namedNode('http://ex.com/temp'),
        object: factory.literal('44', factory.namedNode(xsd.decimal)),
    }, gt, 4, lt, 4, separator, boundary, termNames);
    console.log('GT', textDecoder.decode(gt));
    console.log('LT', textDecoder.decode(lt));
}
//# sourceMappingURL=import2.js.map