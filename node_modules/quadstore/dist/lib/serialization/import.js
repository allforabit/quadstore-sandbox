"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importPattern = exports.serializeImportedQuad = exports.importQuad = exports.importTerm = exports.importRange = exports.importSimpleTerm = exports.importLiteralTerm = void 0;
const fpstring_1 = require("./fpstring");
const xsd = __importStar(require("./xsd"));
const importLiteralTerm = (term, prefixes, rangeBoundary = false) => {
    const { language, datatype, value } = term;
    if (language !== '') {
        return `^^${prefixes.compactIri(xsd.langString)}^${language}^${value}`;
    }
    if (!datatype || datatype.value === xsd.string) {
        return `^^${prefixes.compactIri(xsd.string)}^^${prefixes.compactIri(value)}`;
    }
    switch (datatype.value) {
        case xsd.integer:
        case xsd.double:
        case xsd.decimal:
        case xsd.nonPositiveInteger:
        case xsd.negativeInteger:
        case xsd.long:
        case xsd.int:
        case xsd.short:
        case xsd.byte:
        case xsd.nonNegativeInteger:
        case xsd.unsignedLong:
        case xsd.unsignedInt:
        case xsd.unsignedShort:
        case xsd.unsignedByte:
        case xsd.positiveInteger:
            if (rangeBoundary) {
                return `^number:${fpstring_1.encode(value)}^`;
            }
            return `^number:${fpstring_1.encode(value)}^${prefixes.compactIri(datatype.value)}^^${value}^`;
        case xsd.dateTime:
            const timestamp = new Date(value).valueOf();
            if (rangeBoundary) {
                return `^datetime:${fpstring_1.encode(timestamp)}^`;
            }
            return `^datetime:${fpstring_1.encode(timestamp)}^${prefixes.compactIri(datatype.value)}^^${value}^`;
        default:
            return `^^${prefixes.compactIri(datatype.value)}^^${value}^`;
    }
};
exports.importLiteralTerm = importLiteralTerm;
const importSimpleTerm = (term, isGraph, defaultGraphValue, prefixes, rangeBoundary = false) => {
    if (!term) {
        if (isGraph) {
            return defaultGraphValue;
        }
        throw new Error(`Nil non-graph term, cannot import.`);
    }
    switch (term.termType) {
        case 'NamedNode':
            return prefixes.compactIri(term.value);
        case 'BlankNode':
            return `_:${term.value}`;
        case 'DefaultGraph':
            return defaultGraphValue;
        case 'Literal':
            return exports.importLiteralTerm(term, prefixes, rangeBoundary);
        case 'Variable':
            throw new Error(`Unexpected termType "${term.termType}" in a quad`);
        default:
            throw new Error(`Unsupported termType: "${term.termType}".`);
    }
};
exports.importSimpleTerm = importSimpleTerm;
const importRange = (range, prefixes, rangeBoundary = false) => {
    const importedRange = {};
    if (range.lt)
        importedRange.lt = exports.importLiteralTerm(range.lt, prefixes, rangeBoundary);
    if (range.lte)
        importedRange.lte = exports.importLiteralTerm(range.lte, prefixes, rangeBoundary);
    if (range.gt)
        importedRange.gt = exports.importLiteralTerm(range.gt, prefixes, rangeBoundary);
    if (range.gte)
        importedRange.gte = exports.importLiteralTerm(range.gte, prefixes, rangeBoundary);
    return importedRange;
};
exports.importRange = importRange;
const importTerm = (term, isGraph, defaultGraphValue, prefixes, rangeBoundary = false) => {
    switch (term.termType) {
        case 'NamedNode':
            return prefixes.compactIri(term.value);
        case 'BlankNode':
            return '_:' + term.value;
        case 'Variable':
            return '?' + term.value;
        case 'DefaultGraph':
            return defaultGraphValue;
        case 'Literal':
            if (rangeBoundary) {
                const value = exports.importLiteralTerm(term, prefixes, rangeBoundary);
                return { gte: value, lte: value };
            }
            return exports.importLiteralTerm(term, prefixes, rangeBoundary);
        case 'Range':
            return exports.importRange(term, prefixes, rangeBoundary);
        default:
            throw new Error(`Unsupported termType: "${term.termType}".`);
    }
};
exports.importTerm = importTerm;
const importQuad = (quad, defaultGraphValue, prefixes) => {
    return {
        subject: exports.importSimpleTerm(quad.subject, false, defaultGraphValue, prefixes, false),
        predicate: exports.importSimpleTerm(quad.predicate, false, defaultGraphValue, prefixes, false),
        object: exports.importSimpleTerm(quad.object, false, defaultGraphValue, prefixes, false),
        graph: exports.importSimpleTerm(quad.graph, true, defaultGraphValue, prefixes, false),
    };
};
exports.importQuad = importQuad;
const serializeImportedQuad = (quad) => {
    return JSON.stringify(quad);
};
exports.serializeImportedQuad = serializeImportedQuad;
const importPattern = (terms, defaultGraph, prefixes) => {
    const importedTerms = {};
    if (!terms) {
        return importedTerms;
    }
    if (terms.subject) {
        importedTerms.subject = exports.importTerm(terms.subject, false, defaultGraph, prefixes, true);
    }
    if (terms.predicate) {
        importedTerms.predicate = exports.importTerm(terms.predicate, false, defaultGraph, prefixes, true);
    }
    if (terms.object) {
        importedTerms.object = exports.importTerm(terms.object, false, defaultGraph, prefixes, true);
    }
    if (terms.graph) {
        importedTerms.graph = exports.importTerm(terms.graph, true, defaultGraph, prefixes, true);
    }
    return importedTerms;
};
exports.importPattern = importPattern;
//# sourceMappingURL=import.js.map