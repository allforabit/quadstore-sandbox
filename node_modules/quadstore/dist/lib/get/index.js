"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApproximateSize = exports.getStream = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
const leveliterator_1 = require("./leveliterator");
const serialization_1 = require("../serialization");
const reconcilePatternWithDefaultGraphMode = (pattern, store, opts = utils_1.emptyObject) => {
    const defaultGraphMode = opts.defaultGraphMode || store.defaultGraphMode;
    if (defaultGraphMode === types_1.DefaultGraphMode.DEFAULT && !pattern.graph) {
        return {
            ...pattern,
            graph: store.dataFactory.defaultGraph(),
        };
    }
    if (store.sparqlMode && defaultGraphMode === types_1.DefaultGraphMode.UNION && pattern.graph && pattern.graph.termType === 'DefaultGraph') {
        return {
            subject: pattern.subject,
            predicate: pattern.predicate,
            object: pattern.object,
        };
    }
    return pattern;
};
const getLevelOptsForIndex = (pattern, index, prefixes) => {
    const res = serialization_1.writePattern(pattern, index.prefix, index.terms, prefixes);
    return res ? {
        [res.gte ? 'gte' : 'gt']: res.gt,
        [res.lte ? 'lte' : 'lt']: res.lt,
        keys: true,
        values: true,
        keyAsBuffer: false,
        valueAsBuffer: true,
    } : false;
};
const selectIndexAndGetLevelOpts = (pattern, indexes, prefixes) => {
    for (let i = 0, index, levelOpts; i < indexes.length; i += 1) {
        index = indexes[i];
        levelOpts = getLevelOptsForIndex(pattern, index, prefixes);
        if (levelOpts) {
            return [index, levelOpts];
        }
    }
    throw new Error(`No index found for pattern ${JSON.stringify(pattern, null, 2)}`);
};
const getStream = async (store, pattern, opts) => {
    pattern = reconcilePatternWithDefaultGraphMode(pattern, store, opts);
    const { dataFactory, prefixes, indexes } = store;
    const [index, levelOpts] = selectIndexAndGetLevelOpts(pattern, indexes, prefixes);
    const iterator = new leveliterator_1.LevelIterator(store.db.iterator(levelOpts), (key, value) => {
        return serialization_1.quadReader.read(key, index.prefix.length, value, 0, index.terms, dataFactory, prefixes);
    });
    return { type: types_1.ResultType.QUADS, iterator };
};
exports.getStream = getStream;
const getApproximateSize = async (store, pattern, opts) => {
    pattern = reconcilePatternWithDefaultGraphMode(pattern, store, opts);
    if (!store.db.approximateSize) {
        return { type: types_1.ResultType.APPROXIMATE_SIZE, approximateSize: Infinity };
    }
    const { indexes, prefixes } = store;
    const [, levelOpts] = selectIndexAndGetLevelOpts(pattern, indexes, prefixes);
    const start = levelOpts.gte || levelOpts.gt;
    const end = levelOpts.lte || levelOpts.lt;
    return new Promise((resolve, reject) => {
        store.db.approximateSize(start, end, (err, approximateSize) => {
            if (err) {
                reject(err);
                return;
            }
            resolve({
                type: types_1.ResultType.APPROXIMATE_SIZE,
                approximateSize: Math.max(1, approximateSize),
            });
        });
    });
};
exports.getApproximateSize = getApproximateSize;
//# sourceMappingURL=index.js.map